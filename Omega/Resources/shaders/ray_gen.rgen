#version 460
#extension GL_NV_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable

#include "random.glsl"
#include "payload.glsl"

#define PI 3.141592653589793
#define MIN_DELTA 0.004

layout(set = 0, binding = 0) uniform accelerationStructureNV Scene;
layout(set = 0, binding = 1, rgba8) uniform image2D ResultImage;
layout(set = 0, binding = 2) uniform UniformData 
{
    mat4 viewInverse;
    mat4 projInverse;
    vec4 data;
    vec4 dofgirec;
    vec4 samples;
} ubo;

//layout(set = 0, binding = 8, rgba32f) uniform image2D AccumulationImage;

layout(location = 0) rayPayloadNV Payload tracedData;

vec3 ACESFilm(vec3 x)
{
    float a = 2.51f;
    float b = 0.03f;
    float c = 2.43f;
    float d = 0.59f;
    float e = 0.14f;
    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);
}

void main() 
{

    uint pixelRandomSeed = uint(ubo.data.w);
    tracedData.seed = InitRandomSeed(InitRandomSeed(gl_LaunchIDNV.x, gl_LaunchIDNV.y), pixelRandomSeed);
    float aperture = ubo.data.y;
    int cameraRays = int(ubo.samples.x);

    if(ubo.dofgirec.x == 0)
    {
        cameraRays = 1;
        aperture = 0;
    }

    vec3 col = vec3(0);

    const uint rayFlags = gl_RayFlagsOpaqueEXT;
    const uint cullMask = 0xFF;
    const uint sbtRecordOffset = 0;
    const uint sbtRecordStride = 0;
    const uint missIndex = 0;
    const float tmin = 0.01;
    const float tmax = 500.0;
    const int payloadLocation = 0;

    Payload directPayload;
    Payload indirectPayload;
    cameraRays = 1;
    for(int s = 0; s < cameraRays; ++s)
    {
        vec4 origin;
        vec4 direction;
        if(ubo.dofgirec.x == 1)
        {
            const vec2 pixel = vec2(gl_LaunchIDNV.x + RandomFloat(pixelRandomSeed), gl_LaunchIDNV.y + RandomFloat(pixelRandomSeed));
            const vec2 uv = (pixel / gl_LaunchSizeNV.xy) * 2.0 - 1.0;
            vec2 offset = aperture / 2 * RandomInUnitDisk(tracedData.seed);
            origin = ubo.viewInverse * vec4(offset,0,1);
            vec4 target = ubo.projInverse * vec4(uv.x, uv.y, 1, 1);
            direction = ubo.viewInverse * vec4(normalize(target.xyz * ubo.data.x - vec3(offset, 0)), 0);
        }
        else
        {
            const vec2 pixelCenter = vec2(gl_LaunchIDNV.xy) + vec2(0.5);
            const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeNV.xy);
            vec2 d = inUV * 2.0 - 1.0;

            origin = ubo.viewInverse * vec4(0,0,0,1);
            vec4 target = ubo.projInverse * vec4(d.x, d.y, 1, 1) ;
            direction = ubo.viewInverse* vec4(normalize(target.xyz / target.w), 0) ;
        }
        tracedData.lightSize = int(ubo.data.z);
        tracedData.newOrigin = vec3(origin.xyz);
        tracedData.newDir = vec3(direction.xyz);


        vec3 directLighting;
        //Direct Lighting
        {
            traceNV(Scene, rayFlags, cullMask, sbtRecordOffset, sbtRecordStride, missIndex, 
                    tracedData.newOrigin, tmin, tracedData.newDir, tmax, payloadLocation);
            directPayload = tracedData;

            if(!directPayload.hasHit)
            {
                col = vec3(0.8, 0.99, 1) * 0.1;
                break;
            }

            directLighting = directPayload.color;
        }



        //Global Illumination
        vec3 indirectLighting = vec3(0);

        if(ubo.dofgirec.y == 1)
        {
            vec3 attenuation = vec3(1);
            tracedData.color = vec3(0);
            int div = 0;
            for(int i = 0; i < ubo.dofgirec.z; ++i)
            {
                div++;
                traceNV(Scene, rayFlags, cullMask, sbtRecordOffset, sbtRecordStride, missIndex, 
                        tracedData.newOrigin, tmin, tracedData.newDir, tmax, payloadLocation);

                indirectPayload = tracedData;

                if(!indirectPayload.hasHit)
                {
                    //indirectLighting += vec3(0.8, 0.99, 1) * 0.1;
                    break;
                }

                attenuation *= indirectPayload.color;
                // Russian Roulette
                // Randomly terminate a path with a probability inversely equal to the throughput
                float p = max(attenuation.x, max(attenuation.y, attenuation.z));
                if (RandomFloat(tracedData.seed) > p)
                    break;

                attenuation *= 1 / p;
                indirectLighting += attenuation * directPayload.albedo;
                
            };
            indirectLighting /= div;

        }
        col += directLighting;
        col += indirectLighting;
    }
    col /= cameraRays;
    //col = ACESFilm(col);
    imageStore(ResultImage, ivec2(gl_LaunchIDNV.xy), vec4(col, 1.0));
}